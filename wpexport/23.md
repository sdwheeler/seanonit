In my last post I explained how to
[install ARAPI.NET](http://seanonit.wordpress.com/2014/10/22/installing-bmcs-arapi-net-library/).
Now let's take a look at how you can use the Remedy API in a PowerShell Script. The first trick to
using ARAPI.NET is to ensure that you are running your script with the 32-bit instance of
PowerShell. These days you will most likely be running a 64-bit version of Windows so the default
icon launches the 64-bit version of PowerShell. Look for the icon labelled "Windows PowerShell (x86)"
to launch the 32-bit version. In the example script below I will show you another method for
ensuring that you have a 32-bit instance. This will do a simple query for a Person record in Remedy.
The outline looks like this:

1. Log into the AR Server
1. Build a list of Field IDs that you want to retrieve from Remedy
1. Create a Qualifier string used to query the database
1. Query a Remedy form (passing in the qualifier and field list)
1. Process the results
1. Logoff the AR Server

```powershell
# title="get-remedyuser.ps1"
param ($searchValue="Allen",
       $fieldID=4,
       $ARServerName = "arserver.calbrosvcs.internal",
       $ARSvcAccount = "Demo",
       $ARSvcPassword = "Password",
       $ARAuthentication = "",
       $ARServerPort = 51100,
       $formName = "CTM:People")

if ($Env:PROCESSOR_ARCHITECTURE -ne "x86") {
  $powershell=Join-Path $PSHOME.tolower().replace("system32","syswow64") powershell.exe
  "Launching Windows Powershell (x86)..."
  &"$powershell" -NonInteractive -ExecutionPolicy Bypass $myInvocation.Line
}
else {
   # Load the ARAPI.NET classes
   add-type -path 'C:\Program Files (x86)\BMC Software\ARAPI80.NET\BMC.ARSystem.dll'

   # Login to the AR Server
   $arserver = new-object BMC.ARSystem.Server
   $arserver.Login($ARServerName, $ARSvcAccount, $ARSvcPassword, $ARAuthentication, $ARServerPort)

   # List of field IDs to retrieve from Remedy
   # Hash table of FieldId# = "Display name of field"
   $fieldIDs = @{
               1="Person ID";
               4="Remedy User ID";
               5="Last Modified By";
               6="Last Modified On";
               7="Profile Status";
       200000006="Department";
       260000006="Manager";
       300469300="Cost Center Code";
       301336500="Manager ID";
      1000000001="Company";
      1000000010="Organization";
      1000000018="Last Name";
      1000000019="First Name";
      1000000023="Job Title";
      1000000025="Support Staff";
      1000000026="VIP Status";
      1000000048="Internet Email";
      1000000049="Corporate Email";
      1000000346="Assign Availability";
      1000006694="Authorization Alias";
      1764007102="Network ID";
   }

   # Build the Field List by adding the Field Id numbers
   [BMC.ARSystem.EntryListFieldList] $formEntryFieldList = new-object BMC.ARSystem.EntryListFieldList
   $fieldIDs.Keys | %{ $formEntryFieldList.AddField($_) }

   # Query string - default = search for Person by Remedy ID
   $qualifier = "'{0}' = ""{1}""" -f $fieldID,$searchValue

   # Execute the query
   [BMC.ARSystem.EntryFieldValueList] $entryList = $arserver.GetListEntryWithFields($formName, $qualifier, $formEntryFieldList, 0, 0);

   # Display the results
   foreach ($entry in $entryList) {
     "----------------"
      $fieldIDs.Keys | sort-object |
         foreach-object { "[{0:0000000000}] {1,19} = {2}" -f $_,$fieldIDs[$_],$entry.fieldvalues[$_] }
     "----------------"
   }
   $arserver.Logout()
}
```

Example output:

```
Launching Powershell x86...
----------------
[0000000001]           Person ID = PPL000000002007
[0000000004]      Remedy User ID = Allen
[0000000005]    Last Modified By = AR_ESCALATOR
[0000000006]    Last Modified On = 9/20/2014 1:00:02 AM
[0000000007]      Profile Status = 1
[0200000006]          Department = Customer Service
[0260000006]             Manager = Mary Mann
[0300469300]    Cost Center Code = 100.000012345
[0301336500]          Manager ID = Mary
[1000000001]             Company = Calbro Services
[1000000010]        Organization = Information Technology
[1000000018]           Last Name = Allbrook
[1000000019]          First Name = Allen
[1000000023]           Job Title = Supervisor
[1000000025]       Support Staff = 1
[1000000026]          VIP Status = 1
[1000000048]      Internet Email = allen@calbro.example.com
[1000000049]     Corporate Email = allen@calbro.example.com
[1000000346] Assign Availability = 0
[1000006694] Authorization Alias = allen
[1764007102]          Network ID = allen
----------------
```

---

Let's break this down a bit. First, I define the command line parameters for the script. I have
defaulted the values so that the script searches for Allen Allbrook by default.

```powershell
param ($searchValue="Allen",
       $fieldID=4,
       $ARServerName = "arserver.calbrosvcs.internal",
       $ARSvcAccount = "Demo",
       $ARSvcPassword = "Password",
       $ARAuthentication = "",
       $ARServerPort = 51100,
       $formName = "CTM:People")
```

Any of these parameters can be passed on the command line. For example, if you want to search by
email you could run the script as follows:

`.\get-remeduser.ps1 -searchValue allen@calbro.example.com -fieldID 1000000048`

Next, I check to see if the script is running in a 32-bit instance of PowerShell. Windows sets the
PROCESSOR_ARCHITECTURE environment variable of a process to the reflect processor architecture (e.g.
AMD64 = 64-bit, x86 = 32-bit). This part of the script checks that variable and relaunches the
script using the 32-bit version of PowerShell if necessary.

```powershell
if ($Env:PROCESSOR_ARCHITECTURE -ne "x86") {
  $powershell=Join-Path $PSHOME.tolower().replace("system32","syswow64") powershell.exe
  "Launching Windows Powershell (x86)..."
  &"$powershell" -NonInteractive -ExecutionPolicy Bypass $myInvocation.Line
}
```

Hopefully the rest of the script is fairly self-explanatory. I like to use a hash table for the
Field Ids so that I can map friendly names to the unfriendly field ID numbers.
